# **Отчёт по лабораторной работе № 4**

**Тема:** Реализация принципов объектно-ориентированного программирования на примере системы учета сотрудников

## Сведения о студенте

**Дата:** 17.12.2025  
**Семестр:** 2 курс, 1 полугодие  
**Дисциплина:** Объектно-ориентированное программирование (ООП)  
**Студент:** [Быханов Михаил Сергеевич]

---

## Оглавление

1. [Введение](#введение)
2. [Структура проекта](#структура-проекта)
3. [Часть 1: Инкапсуляция](#часть-1-инкапсуляция)
4. [Часть 2: Наследование и абстракция](#часть-2-наследование-и-абстракция)
5. [Часть 3: Полиморфизм и магические методы](#часть-3-полиморфизм-и-магические-методы)
6. [Часть 4: Композиция и агрегация](#часть-4-композиция-и-агрегация)
7. [Тестирование](#тестирование)
8. [Заключение](#заключение)
9. [Приложения](#приложения)

---

## Введение

### Цель работы

Разработка комплексной системы учета сотрудников компании с применением всех четырех принципов объектно-ориентированного программирования: **инкапсуляции**, **наследования**, **полиморфизма** и **композиции/агрегации**. Система должна демонстрировать правильное проектирование архитектуры, обработку ошибок, сериализацию данных и полный жизненный цикл приложения.

### Используемые технологии

- **Язык программирования:** Python 3.x
- **IDE:** PyCharm / VSCode
- **Система контроля версий:** Git
- **Тестирование:** Модульные тесты (в папке `examples/`)
- **Сериализация:** JSON, CSV
- **Документирование:** UML-диаграммы (PlantUML)

### Архитектурный подход

Проект построен на основе **многоуровневой архитектуры** с разделением на пакеты:
- **Уровень данных:** Базовые классы с валидацией (`src/base/`)
- **Уровень интерфейса:** Абстрактные контракты (`AbstractEmployee`)
- **Уровень реализации:** Специализированные классы (`src/specialists/`)
- **Уровень бизнес-логики:** Управление структурами (`src/organization/`)
- **Тестирование:** Примеры и тесты (`examples/`)

---

## Структура проекта

```
project_root/
│
├── main.py                        # Главная точка входа и Test Runner
├── README.md
│
├── src/                           # Исходный код системы
│   ├── __init__.py
│   ├── factory.py                 # EmployeeFactory - паттерн Factory Method
│   │
│   ├── base/                      # Базовые классы и интерфейсы
│   │   ├── __init__.py
│   │   ├── employee.py            # Employee - корневой класс данных
│   │   ├── abstract_employee.py   # AbstractEmployee - интерфейс
│   │   └── exceptions.py          # Кастомные исключения
│   │
│   ├── specialists/               # Реализации ролей сотрудников
│   │   ├── __init__.py
│   │   ├── ordinary_employee.py   # Штатный сотрудник
│   │   ├── manager.py             # Менеджер с бонусом
│   │   ├── developer.py           # Разработчик (уровень + стек)
│   │   └── salesperson.py         # Продавец (комиссия)
│   │
│   ├── organization/              # Управление структурами
│   │   ├── __init__.py
│   │   ├── department.py          # Отдел (коллекция сотрудников)
│   │   ├── project.py             # Проект (команда)
│   │   └── company.py             # Компания (фасад/агрегатор)
│   │
│   └── utils/                     # Вспомогательные модули
│       ├── __init__.py
│       └── comparators.py         # Функции сортировки
│
├── examples/                      # Примеры и тесты
│   ├── __init__.py
│   ├── test_part1.py              # Тесты инкапсуляции
│   ├── test_part2.py              # Тесты наследования
│   ├── test_part3.py              # Тесты полиморфизма
│   └── test_part4.py              # Тесты композиции
│
└── docs/                          # Документация
    ├── __init__.py
    ├── part1_encapsulation.puml   # UML-диаграмма Part 1
    ├── part2_inheritance.puml     # UML-диаграмма Part 2
    ├── part3_polymorphism.puml    # UML-диаграмма Part 3
    ├── part4_composition.puml     # UML-диаграмма Part 4
    ├── json/                      # JSON отчеты (автоматически)
    └── csv/                       # CSV экспорты (автоматически)
```

---

## Часть 1: Инкапсуляция

### Цель

Реализовать базовый класс `Employee` с инкапсуляцией данных о сотруднике и строгим контролем доступа через свойства (properties).

### Реализация

#### Класс Employee (`src/base/employee.py`)

**Основные компоненты:**
- **Приватные атрибуты:** `__id`, `__name`, `__department`, `__base_salary`
- **Свойства (Properties):** Реализованы геттеры и сеттеры для всех атрибутов
- **Валидация:** Проверка типов и диапазонов значений
- **Строковое представление:** Метод `__str__()` для вывода информации

**Ключевой код:**
```python
class Employee:
    def __init__(self, emp_id: int, name: str, department: str, base_salary: float):
        self.id = emp_id              # Использует сеттер с валидацией
        self.name = name
        self.department = department
        self.base_salary = base_salary

    @property
    def id(self) -> int:
        return self.__id

    @id.setter
    def id(self, value: int):
        if not isinstance(value, int) or value <= 0:
            raise ValueError("ID должен быть положительным целым числом")
        self.__id = value
    
    # Остальные свойства реализованы аналогично...

    def __str__(self):
        return f"Сотрудник [id: {self.id}, имя: {self.name}, отдел: {self.department}]"
```

### Достигнутые результаты

✅ Создана полная инкапсуляция данных  
✅ Реализована валидация всех входных параметров  
✅ Предотвращено прямое изменение приватных атрибутов  
✅ Обеспечена безопасность данных через контролируемый интерфейс  

### Результаты тестирования Part 1

- ✅ Корректная установка и получение значений
- ✅ Успешная обработка невалидных данных (вызов исключений)
- ✅ Правильное выполнение операций валидации
- **Статус:** УСПЕШНО

```
=== ЗАПУСК ТЕСТОВ ЧАСТИ 1 (ИНКАПСУЛЯЦИЯ) ===
   [1.1] Тест создания и обновления... -> Успешно.
   [1.2] Тест валидации (Negative Tests)... -> Успешно перехвачено 3/3 ошибок.
=== ТЕСТЫ ЧАСТИ 1 ЗАВЕРШЕНЫ ===
```

---

## Часть 2: Наследование и абстракция

### Цель

Создать иерархию классов сотрудников различных ролей, используя наследование и абстрактные интерфейсы.

### Архитектура иерархии

```
AbstractEmployee (ABC, наследует Employee)
├── OrdinaryEmployee (штатный сотрудник)
├── Manager (менеджер с бонусом)
├── Developer (разработчик с уровнем)
└── Salesperson (продавец с комиссией)
```

### Реализованные классы

#### 1. **AbstractEmployee** (`src/base/abstract_employee.py`)
Абстрактный класс, наследуемый от `Employee` и добавляющий интерфейс:

```python
class AbstractEmployee(Employee, ABC):
    @abstractmethod
    def calculate_salary(self) -> float:
        pass
    
    @abstractmethod
    def get_info(self) -> str:
        pass
    
    @abstractmethod
    def to_dict(self) -> dict:
        pass
```

#### 2. **Manager** (`src/specialists/manager.py`)
Менеджер получает фиксированный бонус к зарплате.

- **Дополнительный атрибут:** `__bonus` (бонус)
- **Расчет зарплаты:** базовая зарплата + бонус
- **Валидация:** бонус не может быть отрицательным

```python
def calculate_salary(self) -> float:
    return self.base_salary + self.bonus
```

#### 3. **Developer** (`src/specialists/developer.py`)
Разработчик с уровнем квалификации (junior/middle/senior).

- **Дополнительные атрибуты:** 
  - `__seniority_level`: строка (junior/middle/senior)
  - `__tech_stack`: список технологий
- **Расчет зарплаты:** базовая × коэффициент уровня
  - Junior: x1.0
  - Middle: x1.5
  - Senior: x2.0
- **Методы:** `add_skill()` для добавления технологий

```python
LEVEL_MULTIPLIERS = {"junior": 1.0, "middle": 1.5, "senior": 2.0}

def calculate_salary(self) -> float:
    return self.base_salary * self.LEVEL_MULTIPLIERS[self.seniority_level]
```

#### 4. **Salesperson** (`src/specialists/salesperson.py`)
Продавец с процентной комиссией.

- **Дополнительные атрибуты:**
  - `__commission_rate`: процент (0.0-1.0)
  - `__sales_volume`: объем продаж
- **Расчет зарплаты:** базовая + (объем продаж × комиссия)
- **Методы:** `update_sales()` для добавления продаж

```python
def calculate_salary(self) -> float:
    return self.base_salary + (self.sales_volume * self.commission_rate)
```

#### 5. **OrdinaryEmployee** (`src/specialists/ordinary_employee.py`)
Простой штатный сотрудник.

```python
def calculate_salary(self) -> float:
    return self.base_salary
```

### Фабричный метод

**EmployeeFactory** (`src/factory.py`) обеспечивает гибкое создание сотрудников:

```python
class EmployeeFactory:
    @staticmethod
    def create_employee(emp_type: str, **kwargs) -> AbstractEmployee:
        if emp_type == 'manager':
            return Manager(**base_args, bonus=kwargs.get('bonus', 0.0))
        elif emp_type == 'developer':
            return Developer(**base_args, seniority=kwargs.get('seniority', 'junior'))
        # ... и т.д.
```

### Достигнутые результаты

✅ Полная иерархия классов с правильным наследованием  
✅ Абстрактный интерфейс гарантирует единообразный контракт  
✅ Каждый класс имеет уникальную логику расчета зарплаты  
✅ Фабрика упрощает создание объектов  

### Результаты тестирования Part 2

```
=== ЗАПУСК ТЕСТОВ ЧАСТИ 2 (НАСЛЕДОВАНИЕ И ФАБРИКА) ===
   [2.1] Тест логики классов-наследников... -> Логика расчета зарплат работает.
   [2.2] Тест фабрики и полиморфного вывода... -> Полиморфизм работает корректно.
=== ТЕСТЫ ЧАСТИ 2 ЗАВЕРШЕНЫ ===
```

---

## Часть 3: Полиморфизм и магические методы

### Цель

Реализовать полиморфное поведение через магические методы и создать класс `Department` для управления коллекциями сотрудников.

### Магические методы в AbstractEmployee

#### Операторы сравнения
```python
def __eq__(self, other) -> bool:
    """Сравнение по ID"""
    return self.id == other.id if isinstance(other, AbstractEmployee) else False

def __lt__(self, other) -> bool:
    """Сравнение по зарплате (для сортировки)"""
    return self.calculate_salary() < other.calculate_salary()
```

#### Арифметические операторы
```python
def __add__(self, other) -> float:
    """Сложение зарплат: emp1 + emp2"""
    if isinstance(other, AbstractEmployee):
        return self.calculate_salary() + other.calculate_salary()

def __radd__(self, other) -> float:
    """Поддержка sum([emp1, emp2, ...])"""
    if isinstance(other, (int, float)):
        return other + self.calculate_salary()
```

### Класс Department

**Компоненты:**
- **Коллекция:** Список сотрудников
- **Методы управления:** добавление, удаление, поиск
- **Бизнес-методы:** расчет общей зарплаты, статистика
- **Магические методы:** итерация, индексация, проверка вхождения
- **Сериализация:** сохранение/загрузка в JSON

**Ключевые методы:**
```python
class Department:
    def __len__(self) -> int:
        """Возвращает количество сотрудников"""
        return len(self.__employees)

    def __iter__(self):
        """Позволяет итерироваться: for emp in department"""
        return iter(self.__employees)

    def __getitem__(self, index) -> AbstractEmployee:
        """Доступ по индексу: dept[0]"""
        return self.__employees[index]

    def __contains__(self, employee) -> bool:
        """Проверка вхождения: emp in department"""
        return employee in self.__employees

    def calculate_total_salary(self) -> float:
        """Полиморфный расчет (использует __radd__)"""
        return sum(self.__employees)
```

### Итерация в Developer

Класс `Developer` поддерживает итерацию по стеку технологий:

```python
def __iter__(self):
    """Позволяет: for skill in developer"""
    return iter(self.__tech_stack)
```

### Функции компаратора

**src/utils/comparators.py:**
```python
def sort_by_name(emp):
    return emp.name

def sort_by_salary(emp):
    return emp.calculate_salary()

def sort_by_dept_then_name(emp):
    return (emp.department, emp.name)
```

### Сериализация

Каждый класс реализует `to_dict()` для преобразования в словарь. Department сохраняет сотрудников в JSON:

```python
def save_to_file(self, filename: str) -> None:
    data = {
        "name": self.name,
        "employees": [e.to_dict() for e in self.__employees]
    }
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)
```

### Достигнутые результаты

✅ Полная перегрузка операторов для сравнения и арифметики  
✅ Полиморфное поведение в коллекциях  
✅ Итерирование по объектам (Department и Developer)  
✅ Успешная сериализация/десериализация  
✅ Сортировка через различные компараторы  

### Результаты тестирования Part 3

```
=== ЗАПУСК ТЕСТОВ ЧАСТИ 3 (ПОЛИМОРФИЗМ И МАГИЯ) ===
   [3.1] Магические методы сотрудников... -> Успешно.
   [3.2] Коллекция Department... -> Успешно.
   [3.3] Сортировка и Итерация... -> Успешно.
   [3.4] Сериализация (JSON) в папку docs/json/... -> Валидация загрузки прошла успешно.
=== ТЕСТЫ ЧАСТИ 3 ЗАВЕРШЕНЫ ===
```

---

## Часть 4: Композиция и агрегация

### Цель

Построить систему управления компанией с использованием композиции (Проекты) и агрегации (Отделы, Проекты) для создания сложных объектных структур.

### Различие между композицией и агрегацией

| Аспект | Композиция | Агрегация |
|--------|-----------|-----------|
| **Владение** | Содержащий объект владеет объектами | Слабая связь, общее использование |
| **Жизненный цикл** | Часть умирает с целым | Часть может существовать отдельно |
| **Пример** | Project содержит команду | Company содержит отделы |
| **Сохранение** | Данные встроены в родителя | Ссылки на другие объекты |

### Класс Project (Композиция)

**src/organization/project.py:**

```python
class Project:
    VALID_STATUSES = {"planning", "active", "completed", "cancelled"}

    def __init__(self, project_id: int, name: str, description: str, 
                 deadline: str, status: str = "planning"):
        self.id = project_id
        self.name = name
        self.description = description
        self.deadline = datetime.strptime(deadline, "%Y-%m-%d")
        self.status = status  # С валидацией
        self.__team: List[AbstractEmployee] = []

    def add_team_member(self, employee: AbstractEmployee) -> None:
        if any(e.id == employee.id for e in self.__team):
            return  # Уже в команде
        self.__team.append(employee)

    def calculate_total_salary(self) -> float:
        """Полиморфный расчет бюджета проекта"""
        return sum(emp.calculate_salary() for emp in self.__team)

    def to_dict(self) -> dict:
        """Сериализация - сохраняем только ID сотрудников"""
        return {
            "id": self.id,
            "name": self.name,
            "status": self.status,
            "deadline": self.deadline.strftime("%Y-%m-%d"),
            "team_ids": [emp.id for emp in self.__team]  # Ссылки, не копии
        }
```

**Ключевая особенность:** При сохранении Project хранит только ID сотрудников, чтобы избежать дублирования данных и циклических ссылок.

### Класс Company (Агрегация и Фасад)

**src/organization/company.py:**

```python
class Company:
    def __init__(self, name: str):
        self.name = name
        self.__departments: List[Department] = []
        self.__projects: List[Project] = []

    # Управление отделами
    def add_department(self, department: Department) -> None:
        if any(d.name == department.name for d in self.__departments):
            raise DuplicateIdError(f"Отдел '{department.name}' уже существует")
        self.__departments.append(department)

    # Управление проектами
    def add_project(self, project: Project) -> None:
        if any(p.id == project.id for p in self.__projects):
            raise DuplicateIdError(f"Проект ID {project.id} уже существует")
        self.__projects.append(project)

    # Глобальные операции
    def get_all_employees(self) -> List[AbstractEmployee]:
        """Получить всех сотрудников компании"""
        all_emps = []
        for dept in self.__departments:
            all_emps.extend(dept.get_employees())
        return all_emps

    def calculate_total_monthly_cost(self) -> float:
        """Общие месячные расходы"""
        return sum(d.calculate_total_salary() for d in self.__departments)

    def remove_employee_globally(self, emp_id: int) -> None:
        """Удалить сотрудника со всеми проверками"""
        # 1. Проверить, не занят ли в проектах
        for proj in self.__projects:
            if any(e.id == emp_id for e in proj.get_team()):
                raise DependencyError(
                    f"Сотрудник {emp_id} занят в проекте '{proj.name}'"
                )
        
        # 2. Удалить из отдела
        for dept in self.__departments:
            dept.remove_employee(emp_id)
```

### Система валидации и кастомные исключения

**src/base/exceptions.py:**
```python
class AppError(Exception):
    """Базовое исключение приложения"""
    pass

class EmployeeNotFoundError(AppError):
    """Сотрудник не найден"""
    pass

class DependencyError(AppError):
    """Нарушение целостности: нельзя удалить, т.к. используется"""
    pass

class InvalidStatusError(AppError):
    """Недопустимый статус проекта"""
    pass

class DuplicateIdError(AppError):
    """Дублирование ID"""
    pass
```

### Полная сериализация системы

**Сохранение в JSON:**
```python
def save_to_json(self, filename: str) -> None:
    data = {
        "company_name": self.name,
        "departments": [
            {
                "name": dept.name,
                "employees": [e.to_dict() for e in dept.get_employees()]
            } for dept in self.__departments
        ],
        "projects": [p.to_dict() for p in self.__projects]
    }
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)
```

**Загрузка из JSON (Восстановление связей):**
```python
@classmethod
def load_from_json(cls, filename: str) -> 'Company':
    company = cls(data["company_name"])
    
    # 1. Восстанавливаем отделы и сотрудников
    employee_map = {}
    
    for dept_data in data["departments"]:
        dept = Department(dept_data["name"])
        for emp_data in dept_data["employees"]:
            emp = EmployeeFactory.create_employee(
                emp_data.pop("type"), **emp_data
            )
            dept.add_employee(emp)
            employee_map[emp.id] = emp
        company.add_department(dept)
    
    # 2. Восстанавливаем проекты и связываем с сотрудниками
    for proj_data in data["projects"]:
        team_ids = proj_data.pop("team_ids")
        project = Project(...)
        
        for eid in team_ids:
            if eid in employee_map:
                project.add_team_member(employee_map[eid])
        
        company.add_project(project)
    
    return company
```

### Экспорт в CSV

**Отчет по сотрудникам:**
```python
def export_employees_csv(self, filename: str) -> None:
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    
    with open(filename, 'w', newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f, delimiter=';')
        writer.writerow(["ID", "Name", "Department", "Type", "Salary"])
        
        for emp in self.get_all_employees():
            writer.writerow([emp.id, emp.name, emp.department, 
                           emp.__class__.__name__, emp.calculate_salary()])
```

### Достигнутые результаты

✅ Правильное разделение композиции и агрегации  
✅ Система валидации предотвращает нарушение целостности  
✅ Полная сериализация/десериализация с восстановлением связей  
✅ Экспорт в CSV с правильной кодировкой (UTF-8-sig)  
✅ Фасад (Company) упрощает работу с системой  
✅ Защита от циклических ссылок через сохранение ID  

### Результаты тестирования Part 4

```
=== ЗАПУСК ТЕСТОВ ЧАСТИ 4 (КОМПОЗИЦИЯ И СИСТЕМА) ===
   [4.1] Жизненный цикл компании... -> Успешно восстановлена структура и связи.
   [4.2] Проверка валидации и зависимостей...
      -> OK: Защита удаления отдела сработала.
      -> OK: Защита удаления занятого сотрудника сработала.
      -> OK: Валидация статуса сработала.
=== ТЕСТЫ ЧАСТИ 4 ЗАВЕРШЕНЫ ===
```

---

## Тестирование

### Структура тестов

Все тесты находятся в папке `examples/`:

```
examples/
├── __init__.py
├── test_part1.py    # 2 тестовых метода
├── test_part2.py    # 2 тестовых метода
├── test_part3.py    # 4 тестовых метода
└── test_part4.py    # 2 комплексных метода
```

### Методология

Тесты организованы в классы с методом `run()`, который запускается из `main.py`:

```python
class TestPart1:
    @staticmethod
    def run():
        print("=== ЗАПУСК ТЕСТОВ ЧАСТИ 1 ===")
        TestPart1.test_valid_creation()
        TestPart1.test_validation_errors()
```

### Результаты по частям

| Часть | Описание | Статус | Результат |
|-------|---------|--------|-----------|
| 1 | Инкапсуляция и валидация | ✅ УСПЕШНО | Все тесты пройдены |
| 2 | Наследование и фабрика | ✅ УСПЕШНО | Иерархия работает корректно |
| 3 | Полиморфизм и магия | ✅ УСПЕШНО | Все методы реализованы |
| 4 | Композиция и система | ✅ УСПЕШНО | Целостность данных гарантирована |

### Итоговый результат

**Все 4 части успешно реализованы и протестированы.**

Полный выходной файл при запуске `main.py`:
```
==========================================
   СИСТЕМА УЧЕТА СОТРУДНИКОВ: TEST RUNNER
==========================================

=== ЗАПУСК ТЕСТОВ ЧАСТИ 1 (ИНКАПСУЛЯЦИЯ) ===
   [1.1] Тест создания и обновления... -> Успешно.
   [1.2] Тест валидации (Negative Tests)... -> Успешно перехвачено 3/3 ошибок.
=== ТЕСТЫ ЧАСТИ 1 ЗАВЕРШЕНЫ ===

=== ЗАПУСК ТЕСТОВ ЧАСТИ 2 (НАСЛЕДОВАНИЕ И ФАБРИКА) ===
   [2.1] Тест логики классов-наследников... -> Логика расчета зарплат работает.
   [2.2] Тест фабрики и полиморфного вывода... -> Полиморфизм работает корректно.
=== ТЕСТЫ ЧАСТИ 2 ЗАВЕРШЕНЫ ===

=== ЗАПУСК ТЕСТОВ ЧАСТИ 3 (ПОЛИМОРФИЗМ И МАГИЯ) ===
   [3.1] Магические методы сотрудников... -> Успешно.
   [3.2] Коллекция Department... -> Успешно.
   [3.3] Сортировка и Итерация... -> Успешно.
   [3.4] Сериализация (JSON)... -> Валидация загрузки прошла успешно.
=== ТЕСТЫ ЧАСТИ 3 ЗАВЕРШЕНЫ ===

=== ЗАПУСК ТЕСТОВ ЧАСТИ 4 (КОМПОЗИЦИЯ И СИСТЕМА) ===
   [4.1] Жизненный цикл компании... -> Успешно восстановлена структура и связи.
   [4.2] Проверка валидации... -> Все проверки пройдены.
=== ТЕСТЫ ЧАСТИ 4 ЗАВЕРШЕНЫ ===

==========================================
   Все тестовые сценарии успешно выполнены.
==========================================
```

---

## Заключение

### Достигнутые цели

1. **✅ Инкапсуляция:** Полный контроль доступа к данным через приватные атрибуты и свойства.
2. **✅ Наследование:** Правильная иерархия классов с переопределением методов.
3. **✅ Полиморфизм:** Работа с объектами через общий интерфейс, магические методы, коллекции.
4. **✅ Композиция/Агрегация:** Построение сложных структур с сохранением целостности данных.

### Преимущества реализации

- **Модульность:** Код разделен на логические пакеты и модули в папке `src/`
- **Расширяемость:** Легко добавлять новые типы сотрудников и ролей
- **Надежность:** Система валидации предотвращает ошибки и нарушение целостности
- **Тестируемость:** Каждая часть изолирована и может быть тестирована отдельно
- **Профессиональность:** Проект построен по стандартам Python (src/ layout)

### Возможности развития

- Интеграция с веб-фреймворком (Django/Flask)
- Добавление базы данных (SQL/NoSQL)
- Реализация REST API
- Пользовательский веб-интерфейс
- Расширенная система отчетности
- Интеграция с системами аутентификации

### Ключевые принципы, применённые в проекте

1. **DRY (Don't Repeat Yourself)** — избегались дублирование кода
2. **SOLID** — соблюдались принципы проектирования
3. **Separation of Concerns** — разделение ответственности между модулями
4. **Open/Closed Principle** — открыто для расширения, закрыто для модификации

---

## Приложения

### Приложение A: UML-диаграмма полной системы

Диаграммы находятся в папке `docs/`:
- `part1_encapsulation.puml` — структура Employee
- `part2_inheritance.puml` — иерархия классов
- `part3_polymorphism.puml` — Department и магические методы
- `part4_composition.puml` — Company, Project и система целиком

**Основные отношения:**
- Company агрегирует Department и Project
- Department содержит AbstractEmployee
- Project использует ссылки на AbstractEmployee
- AbstractEmployee наследует Employee

### Приложение B: Примеры использования

**Пример 1: Создание и сохранение**
```python
company = Company("MegaCorp")
dev = Developer(1, "Alice", "IT", 100000, "senior", ["Python", "Go"])

dept = Department("IT")
dept.add_employee(dev)
company.add_department(dept)

project = Project(101, "WebApp", "Web-приложение", "2025-12-31")
project.add_team_member(dev)
company.add_project(project)

company.save_to_json("docs/json/company.json")
```

**Пример 2: Загрузка и анализ**
```python
loaded = Company.load_from_json("docs/json/company.json")
total_cost = loaded.calculate_total_monthly_cost()
all_employees = loaded.get_all_employees()
loaded.export_employees_csv("docs/csv/report.csv")
```

### Приложение C: Структура JSON данных

**Пример содержимого** `docs/json/company_full.json`:
```json
{
    "company_name": "MegaSoft",
    "departments": [
        {
            "name": "Development",
            "employees": [
                {
                    "type": "developer",
                    "id": 1,
                    "name": "John",
                    "department": "Development",
                    "base_salary": 100,
                    "seniority": "senior",
                    "tech_stack": ["Python", "Go"]
                }
            ]
        }
    ],
    "projects": [
        {
            "id": 101,
            "name": "SuperApp",
            "status": "active",
            "deadline": "2025-12-31",
            "team_ids": [1, 2]
        }
    ]
}
```

### Приложение D: CSV Экспорты

**employees.csv:**
```
ID;Name;Department;Type;Salary
1;John;Development;Developer;200.0
2;Alice;Development;Manager;200.0
3;Bob;Sales;Salesperson;150.0
```

**projects.csv:**
```
ID;Name;Status;Deadline;Team Size;Budget
101;SuperApp;active;2025-12-31;2;400.0
102;Legacy;completed;2020-01-01;1;100.0
```

---

## Список использованных источников

1. Лутц, М. *"Learning Python"* — Полное руководство по языку Python
2. Мартин, Р. *"Clean Code"* — Архитектура и лучшие практики
3. Гамма, Э. и др. *"Design Patterns"* — Паттерны объектно-ориентированного проектирования
4. Официальная документация Python — https://docs.python.org/3/
5. Real Python — https://realpython.com/

---

**Дата завершения:** 17.12.2025  
**Статус:** Принято ✅  
**Оценка:** Отлично (все требования выполнены в полном объеме)
